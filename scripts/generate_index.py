#!/usr/bin/env python3
"""
Generate a browsable index of all lessons and challenges.

Outputs docs/INDEX.md with links grouped by domain/track/level/module.

Usage:
  python3 scripts/generate_index.py
"""
from __future__ import annotations
import os
import re
from typing import Dict, List

REPO_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
LIB_ROOT = os.path.join(REPO_ROOT, "library")
DOCS_INDEX = os.path.join(REPO_ROOT, "docs", "INDEX.md")

FRONTMATTER_START = re.compile(r"^---\s*$")
FIELD_RE = re.compile(r"^(?P<key>[a-zA-Z0-9_]+):\s*(?P<value>.*)$")


def parse_frontmatter(path: str) -> Dict[str, str] | None:
    try:
        with open(path, "r", encoding="utf-8") as f:
            lines = f.readlines()
    except FileNotFoundError:
        return None

    if not lines or not FRONTMATTER_START.match(lines[0]):
        return None

    fields: Dict[str, str] = {}
    i = 1
    while i < len(lines):
        line = lines[i].rstrip("\n")
        if FRONTMATTER_START.match(line):
            break
        if not line.strip():
            i += 1
            continue
        m = FIELD_RE.match(line)
        if m:
            key = m.group("key").strip()
            value = m.group("value").strip()
            fields[key] = value
        else:
            if ":" in line:
                parts = line.split(":", 1)
                fields[parts[0].strip()] = parts[1].strip()
        i += 1
    return fields


def read_module_title(readme_path: str) -> str | None:
    try:
        with open(readme_path, "r", encoding="utf-8") as f:
            for line in f:
                if line.startswith("# "):
                    return line[2:].strip()
    except FileNotFoundError:
        return None
    return None


def build_index() -> Dict[str, Dict[str, Dict[str, Dict[str, dict]]]]:
    index: Dict[str, Dict[str, Dict[str, Dict[str, dict]]]] = {}
    for base, _, files in os.walk(LIB_ROOT):
        for name in files:
            if not name.endswith(".md"):
                continue
            if not name.startswith("lesson-"):
                continue
            full = os.path.join(base, name)
            rel = os.path.relpath(full, REPO_ROOT).replace("\\", "/")

            parts = rel.split("/")
            if len(parts) < 7:
                continue
            _, domain, track, level, module_dir = parts[:5]
            module_key = "/".join(parts[:5])

            fm = parse_frontmatter(full) or {}
            title = fm.get("title", name)

            index.setdefault(domain, {}) \
                 .setdefault(track, {}) \
                 .setdefault(level, {}) \
                 .setdefault(module_key, {"module_title": None, "lessons": [], "challenges": None})

            index[domain][track][level][module_key]["lessons"].append((title, rel))

    for domain, tracks in index.items():
        for track, levels in tracks.items():
            for level, modules in levels.items():
                for module_key, data in modules.items():
                    readme_path = os.path.join(REPO_ROOT, module_key, "README.md")
                    mod_title = read_module_title(readme_path)
                    if not mod_title:
                        mod_title = module_key.split("/")[-1].replace("-", " ")
                    data["module_title"] = mod_title

                    challenges_path = os.path.join(REPO_ROOT, module_key, "challenges", "README.md")
                    if os.path.exists(challenges_path):
                        data["challenges"] = os.path.relpath(challenges_path, REPO_ROOT).replace("\\", "/")

    return index


def write_markdown(index: Dict[str, Dict[str, Dict[str, Dict[str, dict]]]]) -> None:
    lines: List[str] = []
    lines.append("# Learn-Library — Index\n\n")
    lines.append("Quick links to all tutorials (lessons) and module challenges.\n\n")
    lines.append("Note: This file is generated by `scripts/generate_index.py`.\n\n")

    for domain in sorted(index.keys()):
        lines.append(f"## {domain.capitalize()}\n\n")
        tracks = index[domain]
        for track in sorted(tracks.keys()):
            lines.append(f"### {track.replace('-', ' ').title()}\n\n")
            levels = tracks[track]
            for level in sorted(levels.keys()):
                lines.append(f"#### {level.title()}\n\n")
                modules = levels[level]
                for module_key in sorted(modules.keys()):
                    data = modules[module_key]
                    mod_title = data["module_title"]
                    module_readme_rel = os.path.join(module_key, "README.md").replace("\\", "/")
                    lines.append(f"- {mod_title}\n")
                    for title, rel in sorted(data["lessons"], key=lambda t: t[1]):
                        lines.append(f"  - [Lesson — {title}]({rel})\n")
                    if data["challenges"]:
                        lines.append(f"  - [Challenges]({data['challenges']})\n")
                    if os.path.exists(os.path.join(REPO_ROOT, module_readme_rel)):
                        lines.append(f"  - [Module README]({module_readme_rel})\n")
                lines.append("\n")
            lines.append("\n")
        lines.append("\n")

    os.makedirs(os.path.dirname(DOCS_INDEX), exist_ok=True)
    with open(DOCS_INDEX, "w", encoding="utf-8") as f:
        f.writelines(lines)


def main() -> int:
    index = build_index()
    write_markdown(index)
    print(f"Wrote {os.path.relpath(DOCS_INDEX, REPO_ROOT)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
